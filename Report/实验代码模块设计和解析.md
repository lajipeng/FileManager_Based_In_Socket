### 实验代码模块设计和解析

本次实验采用面向对象编程的思想进行实验。我们定义了两个类：fileClient和fileServer

#### FileClient：

- 初始化函数__init__(self)

  ```python
  # 创建客户的套接字。AF_INET 指示底层网络使用的IPv4，SOCK_STREAM指示套接字类型
  def __init__(self):
          self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  ```

- 连接函数connect(self, ip, port):

  ```python
  # 将服务器的端口号serverPort与该套接字关联起来
  def connect(self, ip, port):
       	self.sock.connect((ip, port))
  ```

- 命令行处理函数 input(self, command):

```python
# command 为用户输入的命令行，我们根据用户输入的信息判断执行哪一类操作
def input(self, command):
    if not command:
        return
    action, filename, filetype = command.split()
    # put代表用户需要存储文件，根据文件的类型（txt\jpg\video）执行不同的发送模式
    # 在发送之前，需要调用self.confirm(command)确认服务器是否已经准备接收数据，
    # 接到服务器指示后，返回True继续执行相应的发送模式
    if action == 'put':
        if filetype == 'txt':
            if self.confirm(command):
                self.sendFile(filename)
            else:
                pass
        elif filetype == 'jpg':
            if self.confirm(command):
                self.sendImage(filename)
            else:
                pass
        elif filetype == 'video':
            if self.confirm(command):
                self.sendVideo(filename)
            else:
                pass
        else:
            pass

    # get代表用户需要取文件，根据文件的类型（txt\jpg\video）执行不同的接收模式
    elif action == 'get':
        if filetype == 'txt':
            self.sock.send(command.encode())
            self.recvFile(filename)
        elif filetype == 'jpg':
            self.sock.send(command.encode())
            self.recvImage(filename)
        elif filetype == 'video':
            self.sock.send(command.encode())
            self.recvVideo(filename)
        else:
            pass
    else:
        pass
```

- 发送确认函数confirm(self, command)

  ```python
  def confirm(self, command):
      self.sock.send(command.encode())
      data = self.sock.recv(4096).decode()
      print(data)
      if data == 'ready':
          return True
  ```

  

- 文件发送和接收函数sendFile(self, filename)和recvFile(self, filename)

  ```python
  # sendFile 执行打开文件并且发送数据，文件发送完毕之后向服务器发送“EOF”表示传输已经完成
  def sendFile(self, filename):
      f = open(filename, 'rb')
      while True:
          data = f.read(4096)
          # print(data)
          if not data:
              print("send all")
              break
          self.sock.sendall(data)
      f.close()
      time.sleep(0.5)
      self.sock.sendall('EOF'.encode())
  # sendFile 执行打开文件并且写入接收的数据，收到“EOF”表示传输已经完成
  def recvFile(self, filename):
      f = open(filename, 'wb')
      while True:
          data = self.sock.recv(4096).decode()
          if data == 'EOF':
              print('copy it!')
              break
          f.write(data.encode())
      f.close()
  ```

- 图片发送和接收函数sendImage(self, filename)和recvImage(self, filename)

```python
def sendImage(self, filename):
    f = open(filename,'rb')
    while True:
        data = f.read(4096)
        # print(data)
        if not data:
            print("send all")
            break
        self.sock.sendall(data)
    f.close()
    time.sleep(1)
    self.sock.sendall('EOF'.encode())

def recvImage(self, filename):
    f = open(filename, 'wb')
    while True:
        data = self.sock.recv(1024)
        # print(data)
        if data == b'EOF':
            print('copy it')
            break
        f.write(data)
    f.close() 
```

- 视频发送和接收函数sendVideo(self, filename)和recvVideo(self, filename)

```python
def sendVideo(self, filename):
    f = open(filename,'rb')
    while True:
        data = f.read(4096)
        # print(data)
        if not data:
            print("send all")
            break
        self.sock.sendall(data)
    f.close()
    time.sleep(1)
    self.sock.sendall('EOF'.encode())
def recvVideo(self, filename):
    f = open(filename, 'wb')
    while True:
        data = self.sock.recv(1024)
        # print(data)
        if data == b'EOF':
            break
        f.write(data)
    f.close()
```

#### fileServer

- 用户请求处理函数handle(self)

  ```python
  # put代表用户需要存储文件，根据文件的类型（txt\jpg\video）执行不同的接收模式
  # get代表用户需要取文件，根据文件的类型（txt\jpg\video）执行不同的发送模式
  def handle(self):
      # 显示连接对象
      print("get connection from :",self.client_address)
      while True:
          try:
              # 接收用户请求
              data = self.request.recv(1024).decode()
              print("get client command:", data) 
              if not data:
                  print("break the connection")
                  break                
              else:
  
                  action, filename, filetype = data.split()
                  if action == "put":
                      if filetype == 'txt':
                          self.recvfile(filename)
                      elif filetype == 'jpg':
                          self.recvImage(filename)
                      elif filetype == 'video':
                          self.recvVideo(filename)
                      else:
                          pass
                  elif action == 'get':
                      if filetype == 'txt':
                          self.sendfile(filename)
                      elif filetype == 'jpg':
                          self.sendImage(filename)
                      elif filetype == 'video':
                          self.sendVideo(filename)
                      else:
                          pass 
                  else:
                      print("get error when action!")
                      continue
          except Exception:
              print("The client has quit! Over")
              break
  ```

- 文件发送和接收函数sendFile(self, filename)和recvFile(self, filename)

  ```python
  def recvfile(self, filename):
      print("start recv")
      f = open(filename, 'wb')
      # 在接收之前服务器向用户发出确认信号
      self.request.send('ready'.encode())
      while True:
          data = self.request.recv(1024).decode()
          # print(data)
          if data == 'EOF':
              print("recv success")
              break
          f.write(data.encode())
      f.close()
  
  def sendfile(self, filename):
      print("start send")
      try:
          f = open(filename, 'rb')
          while True:
              data = f.read(1024)
              if not data:
                  break
              # print(data)
              self.request.send(data)
          f.close()
          time.sleep(0.5)
          self.request.send('EOF'.encode())
          print("send success")
      except:
          self.request.send('EOF'.encode())
  ```

- 图片发送和接收函数sendImage(self, filename)和recvImage(self, filename)

```python
def recvImage(self, filename):
    print("start recv")
    f = open(filename, 'wb')
    self.request.send('ready'.encode())
    while True:
        data = self.request.recv(1024)
        # print(data)
        if data == b'EOF':
            print("recv success")
            break
        f.write(data)
    f.close()
def sendImage(self, filename):
    print("start send")
    # self.request.send('ready'.encode())
    try:
        f = open(filename, 'rb')
        while True:
            data = f.read(1024)
            if not data:
                break
            # print(data)
            self.request.send(data)
        f.close()
        time.sleep(0.5)
        self.request.send('EOF'.encode())
        print("send success")
    except:
        self.request.send('EOF'.encode())
```

- 视频发送和接收函数sendVideo(self, filename)和recvVideo(self, filename)

```python
def recvVideo(self, filename):
    print("start recv")
    f = open(filename, 'wb')
    self.request.send('ready'.encode())
    while True:
        data = self.request.recv(1024)
        # print(data)
        if data == b'EOF':
            print("recv success")
            break
        f.write(data)
    f.close()
def sendVideo(self, filename):
    print("start send")
    # self.request.send('ready'.encode())
    try:
        f = open(filename, 'rb')
        while True:
            data = f.read(1024)
            if not data:
                break
            # print(data)
            self.request.send(data)
        f.close()
        time.sleep(0.5)
        self.request.send('EOF'.encode())
        print("send success")
    except:
        self.request.send('EOF'.encode())
```

#### 握手方式

对于用户，我们使用了python的socket库；对于服务器，我们使用了python的socketserver库

```python
# 用户
fc = fileClient()
IP_fileManager = input("Please into the fileManager IP：")
print ("Connecting: ", IP_fileManager)
fc.connect(IP_fileManager, 1010)
# 服务器
host = '192.168.1.103'
port = 1010
s = socketserver.ThreadingTCPServer((host,port), FileTcpServer)
s.serve_forever()
```

#### 用户界面设计

```python
if __name__ == '__main__':
    fc = fileClient()
    IP_fileManager = input("Please into the fileManager IP：")
    print ("Connecting: ", IP_fileManager)
    fc.connect(IP_fileManager, 1010)
    nameClient = input("Please input your username：")
    passWord = input("Please input your password：")
    print("Loading...")
    print("Welcome back！",nameClient)
    try:
        while True:
            command = input("Please input your command：(put/get filename.txt/jpg/avi txt/jpg/video)\n")
            fc.input(command)
            YN = input("Do you want to continue?(Y/N)\n")
            if(YN == 'N'):
                break
            elif(YN == 'Y'):
                continue
            else:
                print("Input error! Quit")
                break
    except:
        print('error! Quit')
```

### 实验结果

###### 客户端：

<img src="Client.png" alt="Client" style="zoom:70%;" />

服务器端：

<img src="Server.png" alt="Client" style="zoom:100%;" />

### 实验总结：

