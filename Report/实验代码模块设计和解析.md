### 实验代码模块设计和解析

本次实验采用面向对象编程的思想进行实验。我们定义了两个类：fileClient和fileServer

#### FileClient：

- 初始化函数__init__(self)

  ```python
  # 创建客户的套接字。AF_INET 指示底层网络使用的IPv4，SOCK_STREAM指示套接字类型
  def __init__(self):
          self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  ```

- 连接函数connect(self, ip, port):

  ```python
  # 将服务器的端口号serverPort与该套接字关联起来
  def connect(self, ip, port):
       	self.sock.connect((ip, port))
  ```

- 命令行处理函数 input(self, command):

```python
# command 为用户输入的命令行，我们根据用户输入的信息判断执行哪一类操作
def input(self, command):
    if not command:
        return
    action, filename, filetype = command.split()
    # put代表用户需要存储文件，根据文件的类型（txt\jpg\video）执行不同的发送模式
    # 在发送之前，需要调用self.confirm(command)确认服务器是否已经准备接收数据，
    # 接到服务器指示后，返回True继续执行相应的发送模式
    if action == 'put':
        if filetype == 'txt':
            if self.confirm(command):
                self.sendFile(filename)
            else:
                pass
        elif filetype == 'jpg':
            if self.confirm(command):
                self.sendImage(filename)
            else:
                pass
        elif filetype == 'video':
            if self.confirm(command):
                self.sendVideo(filename)
            else:
                pass
        else:
            pass

    # get代表用户需要取文件，根据文件的类型（txt\jpg\video）执行不同的接收模式
    elif action == 'get':
        if filetype == 'txt':
            self.sock.send(command.encode())
            self.recvFile(filename)
        elif filetype == 'jpg':
            self.sock.send(command.encode())
            self.recvImage(filename)
        elif filetype == 'video':
            self.sock.send(command.encode())
            self.recvVideo(filename)
        else:
            pass
    else:
        pass
```

- 发送确认函数confirm(self, command)

  ```python
  def confirm(self, command):
      self.sock.send(command.encode())
      data = self.sock.recv(4096).decode()
      print(data)
      if data == 'ready':
          return True
  ```

  

- 文件发送和接收函数sendFile(self, filename)和recvFile(self, filename)

  ```python
  # sendFile 执行打开文件并且发送数据，文件发送完毕之后向服务器发送“EOF”表示传输已经完成
  def sendFile(self, filename):
      f = open(filename, 'rb')
      while True:
          data = f.read(4096)
          # print(data)
          if not data:
              print("send all")
              break
          self.sock.sendall(data)
      f.close()
      time.sleep(0.5)
      self.sock.sendall('EOF'.encode())
  # sendFile 执行打开文件并且写入接收的数据，收到“EOF”表示传输已经完成
  def recvFile(self, filename):
      f = open(filename, 'wb')
      while True:
          data = self.sock.recv(4096).decode()
          if data == 'EOF':
              print('copy it!')
              break
          f.write(data.encode())
      f.close()
  ```

- 图片发送和接收函数sendImage(self, filename)和recvImage(self, filename)

```python
def sendImage(self, filename):
    f = open(filename,'rb')
    while True:
        data = f.read(4096)
        # print(data)
        if not data:
            print("send all")
            break
        self.sock.sendall(data)
    f.close()
    time.sleep(1)
    self.sock.sendall('EOF'.encode())

def recvImage(self, filename):
    f = open(filename, 'wb')
    while True:
        data = self.sock.recv(1024)
        # print(data)
        if data == b'EOF':
            print('copy it')
            break
        f.write(data)
    f.close() 
```

- 视频发送和接收函数sendVideo(self, filename)和recvVideo(self, filename)

```python
def sendVideo(self, filename):
    f = open(filename,'rb')
    while True:
        data = f.read(4096)
        # print(data)
        if not data:
            print("send all")
            break
        self.sock.sendall(data)
    f.close()
    time.sleep(1)
    self.sock.sendall('EOF'.encode())
def recvVideo(self, filename):
    f = open(filename, 'wb')
    while True:
        data = self.sock.recv(1024)
        # print(data)
        if data == b'EOF':
            break
        f.write(data)
    f.close()
```

- 发送用户密码sendCipher(self, cipher)

  ```python
   # 将用户输入的密码发送给服务器，服务器收到密码后进行核对，如果正确就会发送“right”
  def sendCipher(self, cipher):
      self.sock.send(cipher.encode())
      data = self.sock.recv(4096).decode()
      if data == 'right':
          return True
      else:
          return False
  ```

  

#### fileServer

- 用户请求处理函数handle(self)

  ```python
  # put代表用户需要存储文件，根据文件的类型（txt\jpg\video）执行不同的接收模式
  # get代表用户需要取文件，根据文件的类型（txt\jpg\video）执行不同的发送模式
  def handle(self):
      # 显示连接对象
      print("get connection from :",self.client_address)
      while True:
          try:
              # 接收用户请求
              data = self.request.recv(1024).decode()
              print("get client command:", data) 
              if not data:
                  print("break the connection")
                  break                
              else:
  
                  action, filename, filetype = data.split()
                  if action == "put":
                      if filetype == 'txt':
                          self.recvfile(filename)
                      elif filetype == 'jpg':
                          self.recvImage(filename)
                      elif filetype == 'video':
                          self.recvVideo(filename)
                      else:
                          pass
                  elif action == 'get':
                      if filetype == 'txt':
                          self.sendfile(filename)
                      elif filetype == 'jpg':
                          self.sendImage(filename)
                      elif filetype == 'video':
                          self.sendVideo(filename)
                      else:
                          pass 
                  else:
                      print("get error when action!")
                      continue
          except Exception:
              print("The client has quit! Over")
              break
  ```

- 文件发送和接收函数sendFile(self, filename)和recvFile(self, filename)

  ```python
  def recvfile(self, filename):
      print("start recv")
      f = open(filename, 'wb')
      # 在接收之前服务器向用户发出确认信号
      self.request.send('ready'.encode())
      while True:
          data = self.request.recv(1024).decode()
          # print(data)
          if data == 'EOF':
              print("recv success")
              break
          f.write(data.encode())
      f.close()
  
  def sendfile(self, filename):
      print("start send")
      try:
          f = open(filename, 'rb')
          while True:
              data = f.read(1024)
              if not data:
                  break
              # print(data)
              self.request.send(data)
          f.close()
          time.sleep(0.5)
          self.request.send('EOF'.encode())
          print("send success")
      except:
          self.request.send('EOF'.encode())
  ```

- 图片发送和接收函数sendImage(self, filename)和recvImage(self, filename)

```python
def recvImage(self, filename):
    print("start recv")
    f = open(filename, 'wb')
    self.request.send('ready'.encode())
    while True:
        data = self.request.recv(1024)
        # print(data)
        if data == b'EOF':
            print("recv success")
            break
        f.write(data)
    f.close()
def sendImage(self, filename):
    print("start send")
    # self.request.send('ready'.encode())
    try:
        f = open(filename, 'rb')
        while True:
            data = f.read(1024)
            if not data:
                break
            # print(data)
            self.request.send(data)
        f.close()
        time.sleep(0.5)
        self.request.send('EOF'.encode())
        print("send success")
    except:
        self.request.send('EOF'.encode())
```

- 视频发送和接收函数sendVideo(self, filename)和recvVideo(self, filename)

```python
def recvVideo(self, filename):
    print("start recv")
    f = open(filename, 'wb')
    self.request.send('ready'.encode())
    while True:
        data = self.request.recv(1024)
        # print(data)
        if data == b'EOF':
            print("recv success")
            break
        f.write(data)
    f.close()
def sendVideo(self, filename):
    print("start send")
    # self.request.send('ready'.encode())
    try:
        f = open(filename, 'rb')
        while True:
            data = f.read(1024)
            if not data:
                break
            # print(data)
            self.request.send(data)
        f.close()
        time.sleep(0.5)
        self.request.send('EOF'.encode())
        print("send success")
    except:
        self.request.send('EOF'.encode())
```

- 密码确认函数confirm(self,cipher)

  ```python
  # 服务器收到密码后将会和初始密码进行比对，如果相同则发送“right”
  def confirm(self,data):
      init_password = "AA"
      if data == init_password:
          self.request.send('right'.encode())
      else:
          self.request.send('wrong'.encode())
  ```

#### 握手方式

对于用户，我们使用了python的socket库；对于服务器，我们使用了python的socketserver库

```python
# 用户
fc = fileClient()
IP_fileManager = input("Please into the fileManager IP：")
print ("Connecting: ", IP_fileManager)
fc.connect(IP_fileManager, 1010)
# 服务器
host = '192.168.1.103'
port = 1010
s = socketserver.ThreadingTCPServer((host,port), FileTcpServer)
s.serve_forever()
```

#### 用户界面设计

为了使文件服务管理器更接近真实使用的情况，我们设置了登录名和登录密码，用户登录流程如下：

1. 输入IP地址，连接到服务器

2. 输入用户名Wang Peng，如果输入错误，则系统要求其重新输入

3. 输入用户密码AA，如果输入错误，则系统要求重新输入，如果超过三次输入错误，则系统自动退出。

4. 正确输入密码后，登录成功，用户将被希望输入以下内容：

   put test1.txt txt
   Y
   put test1.jpg jpg
   Y
   put test1.avi video
   Y
   get test2.txt txt
   Y
   get test2.jpg jpg
   Y 
   get test2.avi video

下面是对我们程序的详细解释:

###### 主函数__main__()

```python
if __name__ == '__main__':
    fc = fileClient()
    IP_fileManager = input("Please into the fileManager IP：")
    print ("Connecting: ", IP_fileManager)
    fc.connect(IP_fileManager, 1010)
    # 初始用户名，初始密码由服务器保管
    init_usrname= "Wang Peng"
    flag0=0
while True:    
    nameClient = input("Please input your username：")
    # 如果用户名输入正确
    if nameClient==init_usrname:
        # 限制三次输入的机会
        while flag0<3:
            # 对输入内容加密
            passWord = encryption()
            # fc.sendCipher(passWord)将密码发送给服务器以确认输入密码是否正确
            if fc.sendCipher(passWord):
                print("Loading...")
                print("Welcome back！",nameClient)
                try:
                    while True:
                        command = input("Please input your command：(put/get filename.txt/jpg/avi txt/jpg/video)\n")
                        fc.input(command)
                        YN = input("Do you want to continue?(Y/N)\n")
                        if(YN == 'N'):
                            break
                        elif(YN == 'Y'):
                            continue
                        else:
                            print("Input error! Quit")
                            break
                except:
                    print('error! Quit')
            else:
                # 输错以此密码，机会减1
                flag0+=1
                if flag0<=2:
                    print('\r')
                    print('Wrong Password,enter again!')
        # 输错三次，系统自动退出
        print('\r')
        print("You have tried three times, Quit")
        sys.exit(0)
    else:
        print ('Wrong Username,enter again!')
```

###### 输入密码加密函数encryption():

```python
#密码星号打印
def encryption():
    import msvcrt, os
    print('Please input your password：', end='', flush=True)
    li = []
    while 1:
        ch = msvcrt.getch()
        #回车
        if ch == b'\r':
            return b''.join(li).decode() #把list转换为字符串返回
            break
        #退格
        elif ch == b'\x08':
            if li:
                li.pop()
                msvcrt.putch(b'\b')
                msvcrt.putch(b' ')
                msvcrt.putch(b'\b')
        #Esc
        elif ch == b'\x1b':
            break
        else:
            li.append(ch)
            msvcrt.putch(b'*')
    return b''.join(li).decode()
```



### 实验结果

###### 客户端：

<img src="Client.png" alt="Client" style="zoom:70%;" />

服务器端：

<img src="Server.png" alt="Client" style="zoom:100%;" />

添加密码后的用户界面:

![cipher](/cipher.png)

### 实验总结：

王鹏:

我认为这是一次非常有意思的编程实验,我参考的书籍是计算机网络(自顶向下的方法).我的做法流程是

1 先让两台机器互相连接,这里我犯的最大一个错误是没有正确的输入IP地址,我之前采取的方法是百度直接搜索本地的IP地址,结果百度给我返回了我的路由器的IP地址,这显然是错误的,然而我并没有发现,这也是我为什么在使用指南强调了这一点,因为当我们向cmd输入ipconfig我们会同时收到多个ip地址,如果电脑使用wifi连接,那么应该选择无限局域网WLAN.

2 先定一个小目标,实现传输文本.传输并不难,只要两台电脑握手成功后,数据传输就没有任何问题,关键问题出现在对数据的编解码,文本传输需要先转换为b''类型,然后收到数据后转换为字符串.但是比较坑的地方是f.write(data).这里的data需要先转换为b''才能进行写入.这是非常容易混淆的地方.

3 传输文本实现后,进行图片传输,图片编码是16进制的数据uint16,因此不是字符串,不能使用data.encode().因此encode()和decode()只针对于字符串.令人庆幸地是我们不需要知道这些数据是什么,我们只需要读出写入.

4 视频传输在图片传送成功的基础上进行已经非常容易了,所以基本上没有遇到什么困难.

5 用户密码输入和传输是我认为是文件管理服务器的一个比较重要的点,但是我认为还有很多地方可以完善,比如注册用户名和密码,其次可以添加验证码.然后服务器保管密码的方式也不对,按理讲,用户输入的密码服务器也不应该知道是什么,由于时间关系我并没有仔细研究,这和我们的课程学习也没有很大的关系.

### 使用指南:

- Download the two folders and same them respectively on two different machines
- Go to the /Server and run the  **Run_me_to_activate_server.bat** which is used to run file_server.py. Now the server is running and thus the client can send request to the server.
- Go to the /Client and run the **Run_me_to_login.bat** which is used to run file_client. Now the client is activated. Just follow the instructions.
- Or find the **test.reference*.txt* in /Client 

This is a test reference. You just need to input those content. If you type the wrong cipher, don't worry about it because you have three chances!
Don't forget to change your IP address!

If  your computer is connecting the wifi, I recommend you to choose the follows(after you input "ipconfig" in cmd.exe)

![IPconfig](C:/Github/FileManager_Based_In_Socket/Client/IPconfig.png)

IP：192.168.1.103
Username：Wang Peng
PassWord：AA
Command：put test1.txt txt
Command：Y
Command：put test1.jpg jpg
Command：Y
Command：put test1.avi video
Command：Y
Command：get test2.txt txt
Command：Y
Command：get test2.jpg jpg
Command：Y 
Command：get test2.avi video

Command：N